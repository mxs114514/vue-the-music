# 🎵 收藏功能实现全纪录

## 一、 核心思路与数据库设计

### 1. 需求分析
我们需要实现一个多对多（User <-> Song）的收藏功能，具体要求：
*   用户可以收藏/取消收藏歌曲。
*   需要统计收藏榜（年榜、月榜）。
*   不同用户看到的收藏状态不同。
*   在任何界面（首页、专辑页、播放器）状态需保持同步。

### 2. 数据库建模 (Prisma)
我们选择**显式定义中间表** `Favorite`，而不是使用 Prisma 的隐式多对多，因为我们需要记录 `createdAt` 来实现排行榜。

**最终 Schema 设计：**

```prisma
// server/prisma/schema.prisma

model Favorite {
  id        Int      @id @default(autoincrement()) // 1. 保留单主键，方便前端循环 key
  
  user      User     @relation(fields: [userId], references: [id])
  userId    Int

  song      Song     @relation(fields: [songId], references: [id])
  songId    Int

  createdAt DateTime @default(now()) // 2. 关键字段：用于生成“月榜”、“年榜”

  // 3. 核心约束：防止重复收藏，同时支持通过 (userId, songId) 快速查找
  @@unique([userId, songId]) 
  
  @@index([createdAt])
  @@index([songId])
  @@index([userId])
}
```

### 🛑 踩坑记录 1：Prisma 主键冲突
*   **问题**：最初想用 `@@id([userId, songId])` 做联合主键，同时又保留了 `id Int @id`。
*   **报错**：`Error validating model "Favorite": Each model must have at most one id criteria.`
*   **解决**：保留 `id` 作为主键，将 `[userId, songId]` 改为 `@@unique` 约束。既解决了报错，又保证了业务逻辑（一个用户对同一首歌只能收藏一次）。

---

## 二、 后端实现 (Node.js + Express)

### 1. 核心逻辑：Toggle (切换)
利用 `@@unique` 索引，我们不需要知道收藏记录的 ID，直接通过 `userId` 和 `songId` 就能操作。

```typescript
// server/src/controllers/favorite.controller.ts

export const toggleFavorite = async (req: Request, res: Response) => {
  const userId = req.user?.id
  const { songId } = req.body
  
  // 1. 检查是否存在
  const existing = await prisma.favorite.findUnique({
    where: { userId_songId: { userId, songId } } // Prisma 自动生成的复合键名称
  })

  if (existing) {
    // 2. 存在则删除 (取消收藏)
    await prisma.favorite.delete({
      where: { userId_songId: { userId, songId } }
    })
    res.json({ isFavorited: false, message: '已取消收藏' })
  } else {
    // 3. 不存在则创建 (添加收藏)
    await prisma.favorite.create({
      data: { userId, songId }
    })
    res.json({ isFavorited: true, message: '已添加收藏' })
  }
}
```

### 2. 解决“公开接口无收藏状态”的问题 (关键)
这是本次开发中最大的痛点。

*   **场景**：首页 (`/`) 和 专辑页 (`/albums`) 调用的是 `GET /api/songs`。
*   **问题**：这些是公开页面，不需要强制登录。之前没有加 Auth 中间件。导致即使前端发了 Token，后端 `req.user` 也是 `undefined`，查询数据库时无法判断当前用户是否收藏了这些歌，导致图标一直是灰色的。
*   **解决**：引入 **“可选认证中间件” (`optionalAuthMiddleware`)**。

```typescript
// server/src/middleware/auth.middleware.ts

export const optionalAuthMiddleware = (req: Request, res: Response, next: NextFunction) => {
  const token = req.headers.authorization?.split(' ')[1]
  if (!token) {
    next() // 没 Token？没事，当游客放行
    return
  }
  try {
    const decoded = jwt.verify(token, JWT_SECRET)
    req.user = decoded // 有 Token 且有效？挂载用户信息
  } catch (e) {
    // Token 过期？没事，当游客放行
  }
  next()
}
```

**应用路由：**
```typescript
// server/src/routes/song.routes.ts
router.get('/', optionalAuthMiddleware, getSongs) // 挂载中间件
```

**Controller 修改：**
```typescript
// server/src/controllers/song.controller.ts
// 在查询歌曲时，动态关联查询收藏状态
include: {
  favoritedBy: {
    where: { userId: req.user?.id || 0 }, // 如果是游客(0)，查不到记录；如果是用户，查自己的记录
    select: { userId: true }
  }
}
// 转换结果
isFavorited: song.favoritedBy.length > 0
```

---

## 三、 前端实现 (Vue 3 + Pinia)

### 1. 全局状态管理 (Pinia)
收藏状态需要在播放器、列表、详情页同步，所以逻辑放在 Store 中。

```typescript
// src/stores/player.ts

const toggleFavorite = async (song: Song) => {
  try {
    const res = await toggleFavoriteApi(song.id)
    // 兼容处理：防止 axios 拦截器脱壳导致的取值错误
    const data = res.data || res 
    
    // 1. 更新当前传入的歌曲对象
    song.isFavorited = data.isFavorited
    
    // 2. 同步更新播放器当前播放的歌曲
    if (currentSong.value?.id === song.id) {
      currentSong.value.isFavorited = data.isFavorited
    }
    
    // 3. 弹出提示
    ElMessage({ type: 'success', message: data.message, duration: 1000 })
  } catch (e) {
    console.error(e)
  }
}
```

### 🛑 踩坑记录 2：Axios 响应结构
*   **问题**：`TypeError: Cannot read properties of undefined (reading 'isFavorited')`
*   **原因**：`request.ts` 里的拦截器已经把 `response.data` 返回了，但在 Store 里我们又写了 `res.data.isFavorited`，导致试图访问 `undefined.isFavorited`。
*   **解决**：使用 `const data = res.data || res` 进行兼容处理。

### 2. UI 组件 (SongList.vue)
*   **图标切换**：使用 `v-if` 切换实心/空心图标。
*   **样式调整**：用户反馈红色图标不好看，改为黄色 (`#e6a23c`)。
*   **事件冒泡**：点击收藏按钮时，必须 `e.stopPropagation()`，否则会触发卡片的点击播放事件。

### 3. “我喜欢的音乐” 列表实时移除
*   **需求**：在收藏列表页，取消收藏后，歌曲应立即消失，而不是等刷新。
*   **实现**：
    1.  子组件 `SongList` 抛出事件：`emit('favorite-toggled', song)`。
    2.  父组件 `MyMusicView` 监听事件，使用 `splice` 移除数据。

```typescript
// src/views/MyMusicView.vue
const handleFavoriteToggled = (song: Song) => {
  if (!song.isFavorited) {
    const index = songs.value.findIndex(s => s.id === song.id)
    if (index !== -1) songs.value.splice(index, 1)
  }
}
```

### 🛑 踩坑记录 3：Element Plus 样式丢失
*   **问题**：`ElMessage` 被调用了，控制台无报错，但界面上看不到弹窗。
*   **原因**：在 `main.ts` 中注册了 ElementPlus，但忘记引入 CSS 文件。
*   **解决**：添加 `import 'element-plus/dist/index.css'`。

---

## 四、 总结与最佳实践

1.  **数据库**：对于需要统计时间的多对多关系，**显式中间表**优于隐式中间表。
2.  **接口设计**：
    *   **公开接口 (Public API)** 如果涉及用户个性化数据（如是否收藏），必须使用 **可选认证 (Optional Auth)** 策略。
    *   **列表接口** 最好直接由后端计算好 `isFavorited` 字段返回，不要依赖前端二次处理。
3.  **前端交互**：
    *   **状态同步**：修改一处数据，要考虑到全局（播放列表、当前播放、搜索结果）的同步。
    *   **即时反馈**：列表移除操作使用本地 `splice` 比重新请求接口体验更好。
