# 搜索功能实现总结

## 一、 设计思路

### 1. 前端交互设计
*   **展示方式**：使用独立的搜索结果页 (`/search`)，而不是弹窗。这样可以展示更多信息，且方便分享链接。
*   **数据传递**：使用 **URL Query 参数** (`/search?search=周杰伦`)。
    *   优势：用户刷新页面，搜索结果依然存在；可以通过链接分享搜索结果。

### 2. 后端查询逻辑
*   **匹配模式**：**模糊匹配** (包含关键字即可)。
*   **逻辑关系**：**OR (或)** 关系。
    *   只要 **歌名** OR **歌手** OR **专辑名** 其中任意一个包含关键字，就返回结果。

---

## 二、 详细实现步骤

### 1. 后端：Prisma 查询 (Server)
**文件**：`server/src/controllers/song.controller.ts`

利用 Prisma 的 `OR` 操作符数组和 `contains` 关键字。

```typescript
// 核心代码片段
const where: any = { isDeleted: false }

if (search) {
  where.OR = [
    { title: { contains: String(search) } },  // 搜歌名
    { artist: { contains: String(search) } }, // 搜歌手
    { album: { contains: String(search) } },  // 搜专辑
  ]
}

const songs = await prisma.song.findMany({ where, ... })
```

### 2. 前端：API 封装
**文件**：`src/api/songs.ts`

封装 Axios 请求，将搜索参数作为 `params` 传递。

```typescript
import request from '@/utils/request'

type SearchInput = {
  search?: string
  album?: string
}

export const fetchSearchSongs = (searchInput: SearchInput) => {
  // 注意：后端接口路径是 /songs，参数通过 query string 传递
  return request.get<any[]>('/songs', { params: searchInput })
}
```

### 3. 前端：搜索结果页 (View)
**文件**：`src/views/SearchView.vue`

核心难点在于：**当用户在当前页再次搜索时，组件不会销毁重建，需要监听路由变化。**

```typescript
<script setup lang="ts">
import { ref, onMounted, watch } from 'vue'
import { useRoute } from 'vue-router' // 必须用 useRoute

const route = useRoute()
const songs = ref([])
const keyword = ref('')

const loadData = async () => {
  // 1. 从路由参数获取关键字
  const query = route.query.search as string || ''
  keyword.value = query // 同步给 UI 显示
  
  if (!query) return
  
  // 2. 调用 API
  songs.value = await fetchSearchSongs({ search: query })
}

// 情况 A: 首次进入页面
onMounted(() => {
  loadData()
})

// 情况 B: 在搜索页搜了新词 (URL 变了，但组件没销毁)
watch(() => route.query.search, () => {
  loadData()
})
</script>
```

### 4. 前端：顶部搜索框 (Entry)
**文件**：`src/components/layout/AppHeader.vue`

利用 `v-model` 获取输入，利用 `router.push` 跳转。

```typescript
<script setup lang="ts">
import { ref } from 'vue'
import { useRouter } from 'vue-router'

const searchText = ref('') // 双向绑定变量
const router = useRouter()

const onSearch = () => {
  if (searchText.value.trim()) {
    // 跳转到搜索页，并带上参数
    router.push({ name: 'search', query: { search: searchText.value.trim() } })
  }
}
</script>

<template>
  <!-- 绑定 v-model 和 回车事件 -->
  <el-input 
    v-model="searchText" 
    @keyup.enter="onSearch" 
    placeholder="搜索音乐..." 
  />
</template>
```

---

## 三、 踩坑与解决方案 (Troubleshooting)

在开发过程中，我们遇到了以下 4 个典型问题：

### 1. 路由名称大小写敏感
*   **问题**：`router.push({ name: 'Search' })` 跳转失败。
*   **原因**：在 `router/index.ts` 中定义的 `name` 是 `'search'` (小写)。Vue Router 严格区分大小写。
*   **解决**：统一使用小写 `'search'`。

### 2. Vue Composition API 变量访问
*   **问题**：在 `<script setup>` 中使用了 `$router` 或 `$route` 报错。
*   **原因**：`$` 前缀的变量（如 `$route`）是 Vue 2 Options API 或模板中使用的。在 Composition API (`script setup`) 中必须使用 hook 函数。
*   **解决**：
    ```typescript
    import { useRoute, useRouter } from 'vue-router'
    const route = useRoute()   // 替代 this.$route
    const router = useRouter() // 替代 this.$router
    ```

### 3. TypeScript 类型不匹配
*   **问题**：`fetchSearchSongs` 报错 `Type '{ params: ... }' is not assignable to 'InternalAxiosRequestConfig'`.
*   **原因**：Axios 拦截器使用了内部类型 `InternalAxiosRequestConfig` (要求必有 headers)，但我们调用时传的是普通配置 `AxiosRequestConfig`。
*   **解决**：修改 `src/utils/request.ts`，将导出方法的参数类型放宽为 `AxiosRequestConfig`。

### 4. API 路径错误
*   **问题**：前端请求 `/songs/search` 报 404。
*   **原因**：后端并没有定义 `/search` 子路由，搜索逻辑是写在 `GET /songs` (根路径) 里的。
*   **解决**：前端请求改为 `/songs`，将搜索关键字作为 query 参数传递。

