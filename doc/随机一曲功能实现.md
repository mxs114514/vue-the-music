# 随机一曲功能实现文档

## 1. 需求背景
在首页“今日推荐”列表的第一个位置，展示一个特殊的“随机一曲”卡片。
*   **视觉**：样式与普通歌曲卡片保持一致，但封面使用特殊渐变色和图标。
*   **交互**：点击该卡片时，从所有歌曲中随机选择一首进行播放。

## 2. 核心逻辑层 (Store)
播放逻辑属于全局状态管理，不应写在组件内。
**决策**：在 `Pinia` 的 `player` store 中添加 `playRandomSong` action。

```typescript
// src/stores/player.ts
const playRandomSong = () => {
  if (songList.value.length === 0) return
  // 1. 生成随机索引
  const randomIndex = Math.floor(Math.random() * songList.value.length)
  // 2. 取出歌曲
  const targetSong = songList.value[randomIndex]
  // 3. 复用播放逻辑
  if (targetSong) {
    playSong(targetSong)
  }
}
```

## 3. 踩坑实录：初版方案的教训（不要这样做）

在实现过程中，我们最初采用了**直接修改通用组件**的方案，这成为了一个典型的反面教材。

### 3.1 错误的做法
我们给 `SongList.vue` 添加了一个 `showRandom` 的 Prop，并在组件内部写死了随机卡片的逻辑：

```vue
<!-- SongList.vue (错误示范) -->
<script setup>
// 接收了一个业务相关的 prop
defineProps<{ showRandom?: boolean }>()

const handleRandomPlay = () => { ... }
</script>

<template>
  <div class="song-grid">
    <!-- ❌ 在通用组件里写死了特定业务的 UI -->
    <el-card v-if="showRandom" class="random-card" @click="handleRandomPlay">
       <div class="info">随机一曲</div>
    </el-card>
    
    <el-card v-for="song in songs">...</el-card>
  </div>
</template>
```

### 3.2 为什么这是个坑？
1.  **组件污染**：`SongList` 本该是一个纯粹展示歌曲列表的“哑组件”。加入“随机一曲”后，它被迫了解了首页的业务逻辑。
2.  **维护噩梦**：如果以后“个人中心”页面想要在列表头加一个“新建歌单”按钮，我们是不是又要加一个 `showCreateButton` 的 Prop？组件会变得越来越臃肿，充满了各种 `v-if`。
3.  **样式泄露**：我们不得不在 `SongList` 里写 `random-card` 的样式，即使其他用到 `SongList` 的页面（如个人中心、专辑页）根本不需要这些 CSS。

**修正方案**：使用 **插槽 (Slot)** 将业务逻辑剥离回父组件。

## 4. 最终代码实现 (Slot 方案)

### 4.1 通用组件改造 (`src/components/business/SongList.vue`)

移除所有业务逻辑，仅保留插槽位置。利用 CSS Grid 的特性，如果插槽为空，不会产生任何布局影响。

```vue
<template>
  <div class="song-grid">
    <!-- ✅ 预留插槽：允许父组件在列表前插入自定义内容 -->
    <slot name="prepend" />

    <!-- 原有的歌曲遍历 -->
    <el-card v-for="song in songs" ...>
      ...
    </el-card>
  </div>
</template>
```

### 4.2 业务页面调用 (`src/views/HomeView.vue`)

在父组件中定义卡片样式和交互，这样“随机一曲”的代码就只存在于首页，不会影响其他页面。

```vue
<template>
  <SongList :songs="recommendSongs" ...>
    <!-- ✅ 使用插槽插入随机卡片 -->
    <template #prepend>
      <el-card
        class="song-card random-card"
        shadow="hover"
        @click="playerStore.playRandomSong()"
      >
        <div class="cover-wrapper random-cover">
          <div class="random-icon-wrapper">
            <el-icon><VideoPlay /></el-icon>
          </div>
        </div>
        <div class="info">
          <h3 class="title">随机一哈</h3>
          <p class="artist">点击随机播放</p>
        </div>
      </el-card>
    </template>
  </SongList>
</template>

<style scoped>
/* 定义随机卡片特有的样式 */
/* 注意：插槽内容是在父组件编译的，所以样式写在父组件里 */
.random-card {
  cursor: pointer;
  transition: all 0.3s;
  border: none;
  background-color: var(--el-bg-color);
}
/* ... 其他样式 ... */
</style>
```

## 5. 关键知识点与避坑指南

1.  **开闭原则 (Open/Closed Principle)**：
    *   对扩展开放，对修改关闭。使用插槽可以让组件在不修改源码的情况下支持新场景（比如以后要加个“新建歌单”按钮）。
    
2.  **Grid 布局与插槽**：
    *   CSS Grid 非常智能。如果插槽没有内容，Vue 不会渲染任何元素，Grid 布局也不会产生空白格，完全不影响其他页面的复用。

3.  **样式作用域 (Scoped CSS)**：
    *   `SongList` 内部使用了 `scoped` 样式。
    *   插槽内容是在父组件 (`HomeView`) 编译的，所以插槽内容的样式应该写在父组件中。
    *   **坑点**：不要试图在子组件里写插槽内容的样式（除非使用 `:deep()`），正确的做法是把插槽内容的样式写在提供内容的父组件里。
